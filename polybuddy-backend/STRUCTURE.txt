Structure du projet

polybuddy-back/
├─ src/
│  ├─ config/
│  │   └─ db.js                # Connexion à MongoDB avec Mongoose
│  ├─ controllers/             # Logique pour traiter les requêtes
│  │   ├─ auth.controller.js
│  │   ├─ user.controller.js
│  │   └─ conversation.controller.js
│  ├─ services/                # Gestion des règles métier
│  │   ├─ auth.service.js
│  │   ├─ user.service.js
│  │   └─ message.service.js
│  ├─ models/                  # Schémas Mongoose (entités principales)
│  │   ├─ User.js
│  │   ├─ Student.js
│  │   ├─ Conversation.js
│  │   ├─ Message.js
│  │   └─ Invitation.js
│  ├─ routes/                  # Définition des endpoints REST
│  │   ├─ auth.routes.js
│  │   ├─ users.routes.js
│  │   └─ conversations.routes.js
│  ├─ middlewares/             # Fonctions intermédiaires globales
│  │   ├─ auth.middleware.js   # Vérification du JWT (authentification)
│  │   └─ error.middleware.js  # Gestion centralisée des erreurs
│  ├─ utils/                   # Fonctions utilitaires réutilisables
│  │   ├─ validators.js
│  │   └─ logger.js
│  ├─ app.js                   # Configuration principale d’Express
│  └─ server.js                # Point d’entrée : démarre le serveur
├─ .env                        # Variables d’environnement (PORT, MONGO_URI, JWT_SECRET)
├─ package.json                # Dépendances et scripts du projet
└─ README.md                   # Documentation du projet


Description des dossiers
src/

Dossier principal contenant tout le code backend.

config/

Contient les fichiers de configuration (connexion à la base MongoDB, options du serveur, etc.).

controllers/

Regroupe les fonctions qui répondent aux requêtes HTTP envoyées par le frontend.
Chaque contrôleur appelle un service pour appliquer la logique métier.

services/

Implémente la logique métier (validation des données, traitement des règles d’affaires, etc.).
Les contrôleurs se contentent d’appeler ces fonctions.

models/

Contient les schémas Mongoose, c’est-à-dire la structure des collections (User, Student, Conversation, Message…).

routes/

Définit toutes les routes REST (endpoints) exposées par l’API.
Chaque route appelle le contrôleur correspondant.

Exemple : /api/users → user.controller.js

middlewares/

Contient les fonctions intermédiaires exécutées avant ou après un contrôleur :

auth.middleware.js → vérifie les tokens JWT et protège les routes privées.

error.middleware.js → capture les erreurs globales et renvoie une réponse propre.

utils/

Contient des fonctions génériques et réutilisables (validation, génération d’ID, logs, etc.).

app.js

Configure l’application Express :

Charge les middlewares globaux (CORS, JSON parser, etc.)

Initialise les routes

Connecte la base de données via config/db.js

Exporte l’application vers server.js

server.js

Point d’entrée du backend :

Importe l’application depuis app.js

Lance le serveur sur le port défini dans .env
